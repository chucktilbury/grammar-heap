# grammar-heap
Top-down parser generator that uses a FSM instead of LALR tables or recursive decent. The data structure that it uses to implement the generated parser is a heap.

This uses Bison and Flex to parse a grammar which is composed of simple regular expressions. The parser that is generated uses a single finite state machine to pars the input based upon the grammar. Since it is not recursive, it has no problem with left recursion and any grammer that you can represent with this syntax should be parsable. 

The input is arranged in very simple regulae expressions that are similar to the commonly used format. 

* A grammar consists of a list of rules.
* A rule is a non-terminal followed by an expression that is enclosed in paraentheses.
* An expression can have any combination of functions, terminals, and non-terminals.
* Whitespace is completely ignored except where it separates symbols.
* Comments start with a ``#`` character and end at a newline.

This is a parser generator that generates a FSM parser. It is a work in progress. The goal it to create a working parser and AST generator/traverse from a simplified grammar. A scanner is not generated (yet) and there are specific rules to relate to the case and placement of symbols in the grammar.

* A ``[a-z_][a-z0-9_]*`` is a non terminal symbol. It is defined exactly once and then may be referenced any number of times.
* A ``[A-Z_][A-Z0-9_]*`` is a terminal that must be constructed in the scanner. So when the parser generator encounters a token that looks like ``WOMBAT99`` it will create a token type of ``TOK_WOMBAT99`` and assign a number to it and the generated parser will expect to see a ``TOK_WOMBAT99`` in the input stream. The scanner for the generated parser will return that as a token type when it scans whatever a ``TOK_WOMBAT99`` is supposed to represent.
* A ``\'[a-zA-Z_][a-zA-Z0-9_]*\'`` is a keyword definition such as ``'while'`` or ``'import'``. A token type is created such as ``TOK_WHILE`` and assigned a number. The generated parser refers to it by that symbolic designation.
* A ``\'[^a-zA-Z0-9_\']+\'`` is an operator. For example the string ``'!='`` translates to ``TOK_BANG_EQUAL`` in the generated parser. The scanner for the generated parser must recognize that string and return the token type.
* Comments start with a ``#`` character and continue to the end of the line.
* All non-printable characters are ignored.
* See ``pgen/src/parser/scanner.l`` for the complete scanner rules.

The generated parser simply generates the AST and the code to traverse it. The person using it will use the traverse functions to implement whatever they are trying to do with the parser.

## Requirements

* flex and bison
* cmake
* doxygen
* graphviz (for doxygen)
* Any ANSI C compiler. I am currently using clang 18.
* git (of course)

--------------------

## How it works

The AST generated by the parser actually can be used as nodes in a finite state machine. Each node represents a state in the FSM and each terminal symbol represents a state transition (or an edge in a graph). The input to the FSM defines a path through the state machine. When there is no valid transition present, then a syntax error in the input exists. Error recovery can take place by finding a location in the FSM that allows the next valid input symbol.

Every non-terminal in a grammar can be reduced to include only states and transitions. The entire grammar can be reduced to a single FSM. Instead of backtracking input tokens, backtracking occurs with states.

The states and transitions of the FSM can be realized by defining an array that contains the information needed to determine the next state. A state is assigned a number which is an index into the array. State transitions reference that number.

### Generate the state machine.

The data structure is actually a heap that is represented in array form.

1. Convert each non-terminal into tree form where each non-terminal and all of it's sub-states have a unique identity. (i.e. tree heap)
2. Merge the non-terminals into a single array such that the unique identifier is the index of the node in the array.
3. Reduce the number of states by eliminating states that have exactly one reference to it, have exactly one reference to another state, and have no terminals to match.
4. Convert the tree into an array of integers as described below.


### Traverse the state machine

1. A terminal is read from the input and a search is made from the current position.
2. Push the current position on a stack.
3. If the terminal is found then another terminal is read and the search contiunes from the current position.
4. If the terminal is not found then the position is popped from the stack and the next alternative is searched.
5. If the stack becomes empty and there is a terminal symbol, then a syntax error exists in the input.

### Data structures

The FSM is an array of data structures. To implement the actual parser, this array must be able to be serialized. It can probably take the form of a clean array of unsigned integers.

```
state_number = The index of this word in the array. Used for error checking.
terminal = The terminal that this state matches. If this is zero, then always match.
match_state = The state to jump to if the terminal matches the current terminal.
no_match_state = The state to jump to if the current terminal does not match.
error_state = The state to jump to if a syntax error occoured.
// yes? no? Added by parser implementation?
void* parser_data = Data that will be passed to the action.
void parser_action(void) = Action that the parser match executes.
```

* ``state_number`` -- This is the index of the state in the array. If changing to a state and this does not match the index into the array, then that is an internal error. Somewhere the indexes got mixed up and the system does not continue.
* ``terminal`` -- This is the terminal that this state could match. If this is zero, then it is always a match. For example, this happens when the state is an entry point of a looping function.
* ``match_state`` -- This is the index of the state to jump to if the terminal symbol matches.
* ``no_match_state`` -- This is the index of the state to jump to if the terminal does not match.
* ``error_state`` -- If this is zero, then the no match state is selected. If this is not zero then it is the state to jump to to publish a syntax error and do error recovery.

***note*** The actual state information used to generate the state list will include things that are not actually part of the FSM, such as reference counts.

### Terminal table.
The first section of the array is the terminal table. Terminals may contain literal data, such as a string or a number. Also the name of the terminal is stored there to facilitate error handling.

```
state_number = Same as the FSM state
terminal_number = This is the number that is used in the FSM section of the array
data_table_index = This is the index of the data associated with the terminal.
```

The data table contains a structure somewhat like this:
```
typedef struct {
    int type;
    const char* name;
    union {
        char* str;
        double fval;
        unsigned long ival;
    } value;
} terminal_data_t;
```

Some kind of string table is needed to serialize the strings.

----------------
Here is an example grammar:
```
# This is a grammar for the input to heap.

grammar (
    rule+
)

rule (
    NON_TERMINAL grouping_function+
)

rule_element (
    NON_TERMINAL |
    TERMINAL_SYMBOL |
    TERMINAL_KEYWORD |
    TERMINAL_OPER |
    or_function |
    one_or_more_function |
    zero_or_more_function |
    zero_or_one_function |
    grouping_function
)

or_function (
    rule_element PIPE rule_element
)

one_or_more_function (
    rule_element PLUS
)

zero_or_more_function (
    rule_element STAR
)

zero_or_one_function (
    rule_element QUESTION
)

grouping_function (
    OPAREN rule_element+ CPAREN
)


```
